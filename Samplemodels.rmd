---
title: "MODELS"
author: "Yaswanth"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.




Logistic regressiob for Q.no 4
```{r}
library(aod)
library(ggplot2)
#summary(heart)
mylogit <- glm(HD ~ GeneralHealth+PhysicalActivity , data = total, family = "binomial")
summary(mylogit)
confint(mylogit)
confint.default(mylogit)
wald.test(b = coef(mylogit), Sigma = vcov(mylogit), Terms = 1:2)
exp(coef(mylogit))
exp(cbind(OR = coef(mylogit), confint(mylogit)))
newdata1 <- with(heart, data.frame(GeneralHealth = mean(GeneralHealth), PhysicalActivity = mean(PhysicalActivity), rank = factor(1:2)))
newdata1$rankP <- predict(mylogit, newdata = newdata1, type = "response")
```



Logistic regressiob for Q.no 4
```{r}
install.packages('caTools')
library(caTools)
set.seed(88)
#split <- sample.split(heart$HD, SplitRatio = 0.75)
#dresstrain <- subset(heart, split == TRUE)
#dresstest <- (heart)
#train_sample<-createDataPartition(y = heart$HD, p= 0.7, list = FALSE)
#train_data<-heart[train_sample, ]
#test_data<-heart[-train_sample, ]

model <- glm (HD ~ GeneralHealth+PhysicalActivity, data = total, family = "binomial")
summary(model)
predict <- predict(model, type = 'response')
table(total$HD, predict > 0.5)
#ROCR Curve
library(ROCR)
ROCRpred <- prediction(predict, total$HD)
ROCRperf <- performance(ROCRpred, 'tpr','fpr')
plot(ROCRperf, colorize = TRUE, text.adj = c(-0.2,1.7))
#plot glm
library(ggplot2)
ggplot(train_data, aes(x=GeneralHealth+PhysicalActivity, y=HD)) + geom_point() + 
stat_smooth(method="glm", family="binomial", se=FALSE)
loadPkg("regclass")
confusion_matrix(model)
xkabledply( confusion_matrix(model), title = "Confusion matrix from Logit Model" )
unloadPkg("regclass")
```
For on e increase in Heart Disease General Health decrease by -0.019 and decrease in -0.74 in Physical activity.



Logistic regressiob for Q.no 4

```{r}

model <- glm (HD ~ GeneralHealth+PhysicalActivity+Ethnicity, data =heart, family = "binomial")
summary(model)
```

```{r results='markup'}
xkabledply(model, title = paste("Logistic Regression :", format(formula(model)) ))
```

```{r growthDecayFactors, results='markup', collapse=F}
expcoeff = exp(coef(model))
# expcoeff
xkabledply( as.table(expcoeff), title = "Exponential of coefficients in Logit Reg" )
```

```{r logit_fitted_value}
p_fitted = model$fitted.value# this is the model predicated value p-hat for the first data row (not the actual data point p)  
```  

```{r}
# This gives you the predicted values of the data points inside the model.
predict(model)  # the is from the model, which gives you the value for logit(p) or ln(p/q) 
```

```{r}
newdata1 <- data.frame(GeneralHealth=4, PhysicalActivity=0,Ethnicity=1) # new data frame with 1 row
predict(model, newdata = newdata1)
# The default option is "link", with gives you the value of the link function, 
# in this case, logit(p) or log(p/1-p) value
predict(model, newdata = newdata1, type = "link") -> pred_link # same as predict(model, newdata = newdata1)
paste("This is pred_link: ",pred_link) 

predict(model, newdata = newdata1, type = "response") -> pred_response 
paste("This is pred_response: ",pred_response)

predict(model, newdata = newdata1, type = "term") -> pred_term
paste("This is pred_term, which is a vector with three values, plus the y-intercept term, called `attribute`")
pred_term 
# attr(pred_term,"constant")
```



```{r}
# But this is not "y-value" p that we want to compare to.  
# These three things are the same: 
# 1. using the response option:
predict(model, newdata = newdata1, type = "response")
# 2. Using the link function value (default), to calculate the probability p-hat: 
1/(1+exp(-predict(model, newdata = newdata1))) # 1/(1+exp(-predict(model, newdata = newdata1, type="link")))
# 3. Find the odds-ratio first, then calculate the probability p-hat: 
oddsratio = exp( predict(model, newdata = newdata1, type="link"))
oddsratio / (oddsratio+1)
```

```{r confusionMatrix, results='markup'}
loadPkg("regclass")
xkabledply( confusion_matrix(model), title = "Confusion matrix from Logit Model" )
unloadPkg("regclass")
```

```{r roc_auc}
loadPkg("pROC") # receiver operating characteristic curve, gives the diagnostic ability of a binary classifier system as its discrimination threshold is varied. The curve is on sensitivity/recall/true-positive-rate vs false_alarm/false-positive-rate/fall-out.
prob=predict(model, type = "response" )
heart$prob=prob
h <- roc(HD~prob, data=heart)
auc(h) # area-under-curve prefer 0.8 or higher.
plot(h)
# unloadPkg("pROC")
```

```{r roc_auc}
loadPkg("pROC") # receiver operating characteristic curve, gives the diagnostic ability of a binary classifier system as its discrimination threshold is varied. The curve is on sensitivity/recall/true-positive-rate vs false_alarm/false-positive-rate/fall-out.
prob=predict(model, type = "response" )
heart$prob=prob
h <- roc(HD~prob, data=heart)
auc(h) # area-under-curve prefer 0.8 or higher.
plot(h)
# unloadPkg("pROC")
```


 
```{r}
unloadPkg("pROC")
```
 
Logistic regressiob for Q.no 2
```{r}

model1<- glm (HD ~ SkinCancer+KidneyDisease+Asthma+Diabetic, data =heart, family = "binomial")
summary(model1)
```

```{r results='markup'}
xkabledply(model1, title = paste("Logistic Regression :", format(formula(model)) ))
```

```{r growthDecayFactors, results='markup', collapse=F}
expcoeff = exp(coef(model1))
# expcoeff
xkabledply( as.table(expcoeff), title = "Exponential of coefficients in Logit Reg" )
```

```{r logit_fitted_value}
p_fitted = model1$fitted.values[1] # this is the model predicated value p-hat for the first data row (not the actual data point p)  
```  

```{r}
# This gives you the predicted values of the data points inside the model.
predict(model1)  # the is from the model, which gives you the value for logit(p) or ln(p/q) 
```

```{r}
newdata1 <- data.frame(SkinCancer=1,KidneyDisease=1,Asthma=1,Diabetic=1) # new data frame with 1 row
predict(model1, newdata = newdata1)
# The default option is "link", with gives you the value of the link function, 
# in this case, logit(p) or log(p/1-p) value
predict(model1, newdata = newdata1, type = "link") -> pred_link # same as predict(admitLogit, newdata = newdata1)
paste("This is pred_link: ",pred_link) 

predict(model1, newdata = newdata1, type = "response") -> pred_response 
paste("This is pred_response: ",pred_response)

predict(model1, newdata = newdata1, type = "term") -> pred_term
paste("This is pred_term, which is a vector with three values, plus the y-intercept term, called `attribute`")
pred_term 
# attr(pred_term,"constant")
```



```{r}
# But this is not "y-value" p that we want to compare to.  
# These three things are the same: 
# 1. using the response option:
predict(model1, newdata = newdata1, type = "response")
# 2. Using the link function value (default), to calculate the probability p-hat: 
1/(1+exp(-predict(model1, newdata = newdata1))) # 1/(1+exp(-predict(model, newdata = newdata1, type="link")))
# 3. Find the odds-ratio first, then calculate the probability p-hat: 
oddsratio = exp( predict(model1, newdata = newdata1, type="link"))
oddsratio / (oddsratio+1)
```

```{r confusionMatrix, results='markup'}
loadPkg("regclass")
xkabledply( confusion_matrix(model1), title = "Confusion matrix from Logit Model" )
unloadPkg("regclass")
```

```{r roc_auc}
loadPkg("pROC") # receiver operating characteristic curve, gives the diagnostic ability of a binary classifier system as its discrimination threshold is varied. The curve is on sensitivity/recall/true-positive-rate vs false_alarm/false-positive-rate/fall-out.
prob=predict(model1, type = "response" )
heart$prob=prob
h <- roc(HD~prob, data=heart)
auc(h) # area-under-curve prefer 0.8 or higher.
plot(h)
# unloadPkg("pROC")
```


```{r}
loadPkg("rpart") # Classification trees, rpart(formula, data=, method=,control=) 
```

```{r, echo = T, fig.dim=c(6,4)}
set.seed(1)
HDfit <- rpart(HD ~ GeneralHealth + PhysicalActivity+Ethnicity , data=heart, method="class", control = list(maxdepth = 4) )
# kyphosisfit <- rpart(Kyphosis ~ Age + Number + Start, data=kyphosis, method="class", control = {rpart.control list} )
# rpart.control(maxdepth = 30, minsplit = 20, minbucket = round(minsplit/3), cp = 0.01, maxcompete = 4, maxsurrogate = 5, usesurrogate = 2, xval = 10, surrogatestyle = 0, ...)
printcp(HDfit) # display the results 
plotcp(HDfit) # visualize cross-validation results 
summary(HDfit) # detailed summary of splits
```

# plot tree 
plot(HDfit, uniform=TRUE, main="Classification Tree for Kyphosis")
text(HDfit, use.n=TRUE, all=TRUE, cex=.8)


```{r}
# create attractive postcript plot of tree 
post(HDfit, file = "kythosisTree2.ps", title = "Classification Tree for Kythosis")
```

```{r}
newdata1<- subset(heart, HD==1)
newdata1_1<-head(newdata1,27373)
nrow(newdata1_1)
newdata0<- subset(heart, HD==0)
newdata0_1<-head(newdata0,27373)
nrow(newdata0_1)
total <- rbind(newdata1_1, newdata0_1)
nrow(total)
summary(total)
```


```{r}

model <- glm (HD ~ GeneralHealth+PhysicalActivity, data =total, family = "binomial")
summary(model)
```

```{r results='markup'}
xkabledply(model, title = paste("Logistic Regression :", format(formula(model)) ))
```

```{r growthDecayFactors, results='markup', collapse=F}
expcoeff = exp(coef(model))
# expcoeff
xkabledply( as.table(expcoeff), title = "Exponential of coefficients in Logit Reg" )
```

```{r logit_fitted_value}
p_fitted = model$fitted.value# this is the model predicated value p-hat for the first data row (not the actual data point p)  
```  

```{r}
# This gives you the predicted values of the data points inside the model.
predict(model)  # the is from the model, which gives you the value for logit(p) or ln(p/q) 
```

```{r}
newdata1 <- data.frame(GeneralHealth=4, PhysicalActivity=0) # new data frame with 1 row
predict(model, newdata = newdata1)
# The default option is "link", with gives you the value of the link function, 
# in this case, logit(p) or log(p/1-p) value
predict(model, newdata = newdata1, type = "link") -> pred_link # same as predict(model, newdata = newdata1)
paste("This is pred_link: ",pred_link) 

predict(model, newdata = newdata1, type = "response") -> pred_response 
paste("This is pred_response: ",pred_response)

predict(model, newdata = newdata1, type = "term") -> pred_term
paste("This is pred_term, which is a vector with three values, plus the y-intercept term, called `attribute`")
pred_term 
# attr(pred_term,"constant")
```



```{r}
# But this is not "y-value" p that we want to compare to.  
# These three things are the same: 
# 1. using the response option:
predict(model, newdata = newdata1, type = "response")
# 2. Using the link function value (default), to calculate the probability p-hat: 
1/(1+exp(-predict(model, newdata = newdata1))) # 1/(1+exp(-predict(model, newdata = newdata1, type="link")))
# 3. Find the odds-ratio first, then calculate the probability p-hat: 
oddsratio = exp( predict(model, newdata = newdata1, type="link"))
oddsratio / (oddsratio+1)
```

```{r confusionMatrix, results='markup'}
loadPkg("regclass")
xkabledply( confusion_matrix(model), title = "Confusion matrix from Logit Model" )
unloadPkg("regclass")
```

```{r roc_auc}
loadPkg("pROC") # receiver operating characteristic curve, gives the diagnostic ability of a binary classifier system as its discrimination threshold is varied. The curve is on sensitivity/recall/true-positive-rate vs false_alarm/false-positive-rate/fall-out.
prob=predict(model, type = "response" )
total$prob=prob
h <- roc(HD~prob, data=total)
auc(h) # area-under-curve prefer 0.8 or higher.
plot(h)
# unloadPkg("pROC")
```

```{r roc_auc}
loadPkg("pROC") # receiver operating characteristic curve, gives the diagnostic ability of a binary classifier system as its discrimination threshold is varied. The curve is on sensitivity/recall/true-positive-rate vs false_alarm/false-positive-rate/fall-out.
prob=predict(model, type = "response" )
heart$prob=prob
h <- roc(HD~prob, data=heart)
auc(h) # area-under-curve prefer 0.8 or higher.
plot(h)
# unloadPkg("pROC")
```

```{r}
mod1 <- glm(HD ~ GeneralHealth + PhysicalActivity,data=total,family = "binomial")
summary(mod1)
```
``` {r}
xkabledply(mod1, title = paste("Logistic Regression :", format(formula(mod1)) ))
```
```{r}
predicted<- predict(mod1, total, type = "response")
hist(predicted)
```
```{r growthDecayFactors, results='markup', collapse=F}
expcoeff = exp(coef(mod1))
# expcoeff
xkabledply( as.table(expcoeff), title = "Exponential of coefficients in Logit Reg" )
```


```{r confusionMatrix, results='markup'}
loadPkg("regclass")
# confusion_matrix
xkabledply( confusion_matrix(mod1), title = "Confusion matrix from Logit Model" )
unloadPkg("regclass")
```

```{r, echo = T, fig.dim=c(6,4)}
set.seed(1)
kyphosisfit <- rpart(HD ~ GeneralHealth + PhysicalActivity, data=total, method="class", control = list(maxdepth = 4) )
# kyphosisfit <- rpart(Kyphosis ~ Age + Number + Start, data=kyphosis, method="class", control = {rpart.control list} )
# rpart.control(maxdepth = 30, minsplit = 20, minbucket = round(minsplit/3), cp = 0.01, maxcompete = 4, maxsurrogate = 5, usesurrogate = 2, xval = 10, surrogatestyle = 0, ...)
printcp(kyphosisfit) # display the results 
plotcp(kyphosisfit) # visualize cross-validation results 
summary(kyphosisfit) # detailed summary of splits

# plot tree 
plot(kyphosisfit, uniform=TRUE, main="Classification Tree for Kyphosis")
text(kyphosisfit, use.n=TRUE, all=TRUE, cex=.8)

```

```{r}
# create attractive postcript plot of tree 
post(kyphosisfit, file = "kythosisTree2.ps", title = "Classification Tree for Kythosis")
```

```{r}
# Exponential Coefficients  & Confidence Interval 
exp(cbind(OR = coef(model), confint(model)))
```
